package org.batfish.multigraph;

import java.util.ArrayList;
import java.util.Map;

public class RYen {

    Digraph g;

    public RYen(Digraph graph) {    
        g = graph;
    }

    /**
     * Computes the K shortest paths in a graph from Node s to Node t using RYen's algorithm
     *
     * @param src   the starting Node for all of the paths
     * @param dst   the ending Node for all of the paths
     * @param K             the number of shortest paths to compute
     * @return List<Path>            a list of the K shortest paths from s to t, ordered from shortest to longest
     */
    public ArrayList<Path> ksp(Node src, Node dst, int K) {
        // Initialize containers for candidate paths and k shortest paths
        ArrayList<Path> ksp = new ArrayList<>();
        ArrayList<Integer> kspFailures = new ArrayList<>();
        ArrayList<Path> candidates = new ArrayList<>();
        ArrayList<Integer> candidateFailures = new ArrayList<>();
        BF bf = new BF(g);

        ArrayList<Path> curCandidates = new ArrayList<>();
        ArrayList<Integer> curFails = new ArrayList<>();

        ArrayList< Map<Node, Map<String, Boolean>> > kspCommMap = new ArrayList<>();
        ArrayList< Map<Node, Map<String, Boolean>> > candidateMap = new ArrayList<>();


        try {
            /* Compute and add the shortest path */
            Path kthPath = new Path();
            int kthPathFailure = -1;
            Map<Node, Map<String, Boolean>> kthPathMap = null;
            kthPath = bf.shortestPath(src, dst);
            if (kthPath == null) {
                return ksp;
            }
            //System.out.println(kthPath);
            ksp.add(kthPath);
            kspFailures.add(0);
            kspCommMap.add(bf.getSeen());
            curCandidates.add(kthPath);
            curFails.add(0);

            K = kthPath.getEdgesize() + 1;

            int seen = 1;
            int pref = 1;
            /* Iteratively compute each of the k shortest paths */
            for (int k = 1; k < K; k++) {

                if ( k == seen) {
                    //System.out.println(" Pref : " + curCandidates);
                    pref = pref + 1;
                    if (k >= K) {

                    }
                }

                // Get the (k-1)st shortest path
                Path previousPath = ksp.get(k-1);

                /* Iterate over all of the Vertexs in the (k-1)st shortest path except for the target Node; for each Node,
                   (up to) one new candidate path is generated by temporarily modifying the graph and then running
                   Dijkstra's algorithm to find the shortest path between the Node and the target in the modified
                   graph */
                for (int i = 0; i < previousPath.getEdgesize(); i++) {
                    // Initialize a container to store the modified (removed) edges for this Node/iteration
                    ArrayList<Edge> removedEdges = new ArrayList<Edge>();

                    // Spur Node = currently visited Node in the (k-1)st shortest path
                    //System.out.println(previousPath.getEdges()); previousPath.getEdgesize()
                    Node spurVertex = previousPath.getVertex(previousPath.getEdgesize() - i);
                    // System.out.println("K = "+ k + " i = " + i + " Spur Node " + spurVertex);
                    // Root path = prefix portion of the (k-1)st path up to the spur Node
                    Path rootPath = previousPath.cloneFrom(i);

                    //System.out.println(spurVertex + "\t" + rootPath);

                    /* Iterate over all of the (k-1) shortest paths */
                    for(Path p : ksp) {

                        Path stub = p.cloneFrom(i);
                        //System.out.println("\t\t" + p);
                        ////System.out.println(i + "\t\t" + stub + "" + rootPath);
                        // Check to see if this path has the same prefix/root as the (k-1)st shortest path
                        if (rootPath.equals(stub)) {
                            /* If so, eliminate the next edge in the path from the graph (later on, this forces the spur
                               Node to connect the root path with an un-found suffix path) */
                            int index = p.getEdgesize() - i - 1;
                            Edge re = p.getEdge(index);
                            Edge removing = re.copy();
                            g.removeEdge(re.copy());
                            removedEdges.add(removing);
                            ////System.out.println(re);
                        }
                    }
                    /* Temporarily remove all of the Vertexs in the root path, other than the spur Node, from the graph */
                    for(Edge rootPathEdge : rootPath.getEdges()) {
                        Node rn = rootPathEdge.getDst();
                        if (!rn.getId().equals(spurVertex.getId())) {
                            removedEdges.addAll(g.removeVertex(rn.getId()));
                            ////System.out.println(rn);
                        }
                    }
                    // Spur path = shortest path from spur Node to target Node in the reduced graph
                    bf.initializeGraph();
                    bf.setSeen(spurVertex, kspCommMap.get(k-1).get(spurVertex));

                    Path spurPath = bf.shortestPath(src, spurVertex);
                    ////System.out.println("\t" + src + " " + spurVertex + spurPath);

                    ////System.out.println("\n\n\n");
                    /*
                    System.out.println("Edges removed " + removedEdges);
                    //System.out.println(g);
                    System.out.println("\n " + spurVertex + " " + dst + "\tPath: "+spurPath);
                    //*/
                    // If a new spur path was identified...
                    if (spurPath != null) {
                        // Concatenate the root and spur paths to form the new candidate path
                        Path totalPath = spurPath.clone();
                        //System.out.println();
                        totalPath.addPath(rootPath);
                        // If candidate path has not been generated previously, add it
                        int index = candidates.indexOf(totalPath);
                        if (index == -1) {
                            candidates.add(totalPath);
                            candidateMap.add(bf.getSeen());
                            candidateFailures.add(removedEdges.size());
                        } else {
                            //System.out.println("Candidate exists");
                            if ( candidateFailures.get(index) > removedEdges.size())
                                candidateFailures.set(index, removedEdges.size());
                        }
                    }
                    //System.out.println("\t\tEdges removed " + removedEdges);
                    // Restore all of the edges that were removed during this iteration
                    g.addEdges(removedEdges);
                }

                /* Identify the candidate path with the shortest cost */
                boolean isNewPath = false;
                kthPath = null;
                kthPathMap = null;
                do {
                    if (candidates.size() <= 0) {
                        break;
                    }
            
                    kthPath = candidates.get(0);
                    kthPathFailure = candidateFailures.get(0);
                    kthPathMap = candidateMap.get(0);

                    candidateMap.remove(0);
                    candidates.remove(0);
                    candidateFailures.remove(0);
                    isNewPath = true;
                    if (kthPath != null) {
                        for (Path p : ksp) {
                            // Check to see if this candidate path duplicates a previously found path
                            if (p.equals(kthPath)) {
                                //System.out.println("Path exists");
                                isNewPath = false;
                                kthPath = null;
                                break;
                            }
                        }
                    }
                } while(!isNewPath);
            
                // If there were not any more candidates, stop
                if (kthPath == null)
                    break;
                // Add the best, non-duplicate candidate identified as the k shortest path
                ksp.add(kthPath);
                kspCommMap.add(kthPathMap);

                kspFailures.add(kthPathFailure);

                //System.out.println(kthPath + " " + seen + " " + (candidates.size()+1));
                if ( k == seen) {
                    seen = seen + candidates.size() + 1; 
                    //System.out.println("Seen " + seen + " Pref : " + pref + ksp);
                    curCandidates.clear();
                    curFails.clear();
                }
                curCandidates.add(kthPath);
                curFails.add(kthPathFailure);

            }
        } catch (Exception e) {
            System.out.println(e);
            e.printStackTrace();
        }

        // Return the set of k shortest paths
        //System.out.println(ksp + "\n" + kspFailures);
        return ksp;
    }


}